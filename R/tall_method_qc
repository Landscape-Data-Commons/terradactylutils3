

####################################
#' Tall LPI QC
#'
#'after the lpi tall table is prepared for terradactylutils2::geofiles() using terradactylutils2::clean_tall_lpi(), this function produces the tall_lpi file QC checks
#'
#' @param cleaned_tall_lpi as a data.frame, the tall lpi data that has been through terradactylutils2::clean_tall_lpi
#' @param speciescode the column name in the USDA plant list file that contains the four letter codes
#' @param USDA_plants a data.frame of the USDA plants with the 4 letter code, GrowthHabit and Duration
#' @param tblLPIDetail as a data.frame, the tblLPIDetail from the DIMA tables
#' @param path_qc path where the QC data will be saved
#'
#' @return a CSV containing information about the QC of the tall lpi data saved to the designated QC file
#' @export
#'
#' @examples tall_lpi_qc(cleaned_tall_lpi = cleaned_tall_lpi, speciescode = "UpdatedSpeciesCode", tblLPIDetail = tblLPIDetail, USDA_plants = read.csv("D:/modifying_data_prep_script_10032025/2004-2023_ceap_species_list.csv") , path_qc = file.path("D:/modifying_data_prep_script_10032025/NWERN_HAFB_10132025/QC")))
tall_lpi_qc <- function(cleaned_tall_lpi, speciescode, USDA_plants, tblLPIDetail, path_qc){
  # list two letter codes and compare to terradat
tall_lpi <- cleaned_tall_lpi
  #get two letter codes
  two_letter <- tall_lpi[nchar(tall_lpi$code) <= 2, ]

  # only keep the unique codes
  #two_letter <- two_letter[!duplicated(two_letter$code),]

  # this is the list currently used in terradactyl for two letter codes
  terra_two_letter <- c("L","HL", "AM", "DN", "ER", "HT", "NL","AL","DS","D","LC","M","WL", "CY","EL",
                        "W","WA","RF","R","GR","ST","CB","BY","VL","AG","CM","LM","FG","PC",
                        "BR","S")
  # determine whether the tall lpi code is associated with the terradactyl two letter codes, if not provide feedback
  two_letter$tl_error <- ifelse(two_letter$code %in% terra_two_letter, 0, 1)
  two_letter$Notes <- ifelse(two_letter$tl_error == 1,
                             "Two letter codes present that are not associated with terradactyl codes", NA)
  two_letter$Action = ifelse(two_letter$tl_error == 1, "Check with project manager to determine what code represents", NA)
  two_letter <- two_letter |> dplyr::select(PrimaryKey, DBKey, LineKey, RecKey, layer, code, Notes, Action)

  # joining multiple tall lpi tables was machine space expensive - only keeping the plots with feedback for later joining
  two_letter <- two_letter[!is.na(two_letter$Notes),]



  # check same number of unique codes as og data
  # get the unique codes from the original data table
  og_codes <- c(tblLPIDetail$TopCanopy, tblLPIDetail$Lower1, tblLPIDetail$Lower2, tblLPIDetail$Lower3,
                tblLPIDetail$Lower4,tblLPIDetail$Lower5, tblLPIDetail$Lower6, tblLPIDetail$Lower7,
                tblLPIDetail$SoilSurface)
  og_codes <- unique(og_codes)

  #determine whether the tall lpi code is a code from the original data
  tall_lpi_codes <- tall_lpi

  tall_lpi_codes$add_codes <- ifelse(tall_lpi_codes$code %in% og_codes, 0, 1)

  # provide feedback where tall lpi codes are not in the original data
  tall_lpi_codes$Notes <- ifelse(tall_lpi_codes$add_codes == 1,
                                 "Codes present that are not in the original data", NA)

  tall_lpi_codes$Action <- ifelse(tall_lpi_codes$add_codes == 1,
                                  "Determine whether code addition was intentional", NA)
  tall_lpi_codes <- tall_lpi_codes |> dplyr::select(PrimaryKey, DBKey, LineKey, RecKey, layer, code, Notes, Action)

  # joining multiple tall lpi tables was machine space expensive - only keeping the plots with feedback for later joining
  tall_lpi_codes <- tall_lpi_codes[!is.na(tall_lpi_codes$Notes),]




  # looking for soil surface codes that are not terradactyl accepted soil surface codes
  # get the unique two letter soil surface codes from the tall lpi
  ss <- tall_lpi |> filter(layer == "SoilSurface")
  ss <- ss[nchar(ss$code) <= 2, ]
  #ss <- ss[!duplicated(ss$code),]
  # these are the two letter surface codes used in terradactyl
  terra_two_letter_surf <- c("DS","D","LC","M", "CY", "EL",
                             "W","WA","RF","R","GR","ST","CB","BY","VL","AG","CM","LM","FG","PC",
                             "BR","S")

  # determine whether the tall lpi surface code is one of the codes from terradactyl

  ss$add_codes <- ifelse(ss$code %in% terra_two_letter_surf, 0, 1)

  # provide feedback where the tall lpi surface code is not associated with the terradactyl codes
  ss$Notes <- ifelse( ss$add_codes == 1,
                      "Soil surface codes present that are not associated with terradactyl", NA)

  ss$Action <- ifelse(ss$add_codes == 1,
                      "Check with the project manager to determine what the code represents", NA)
  ss <- ss |> dplyr::select(PrimaryKey, DBKey, LineKey, RecKey, layer, code, Notes, Action)

  # joining multiple tall lpi tables was machine space expensive - only keeping the plots with feedback for later joining
  ss <- ss[!is.na(ss$Notes),]



  ## identifying where the tall lpi codes are not a USDA plant code
  #get the accepted USDA plant codes
  USDA_plant_codes <- USDA_plants[,paste0(speciescode)]


  # checking that the tall_lpi codes are in the USDA database
  tall_lpi_plant_codes <- tall_lpi[nchar(tall_lpi$code) > 2, ]


  tall_lpi_plant_codes$usda_code <- ifelse(tall_lpi_plant_codes$code %in% USDA_plant_codes, 0, 1)

  # providing feedback for the tall lpi codes that are not in the USDA plant code list
  tall_lpi_plant_codes$Notes <- ifelse( tall_lpi_plant_codes$usda_code == 1,
                                        "Codes present that are not an accepted USDA plant code", NA)
  tall_lpi_plant_codes$Action <- ifelse(tall_lpi_plant_codes$usda_code ==1,
                                        "If not unknown code, confirm with project manager the correct USDA plant code or species attributes", NA)
  tall_lpi_plant_codes <- tall_lpi_plant_codes |> dplyr::select(PrimaryKey, DBKey, LineKey, RecKey, layer, code, Notes, Action)

  # joining multiple tall lpi tables was machine space expensive - only keeping the plots with feedback for later joining
  tall_lpi_plant_codes <- tall_lpi_plant_codes[!is.na(tall_lpi_plant_codes$Notes),]


  # joining the errors for the tall lpi data

  tall_lpi_code_check <-  rbind(two_letter, tall_lpi_codes) %>%
    rbind(., ss) %>% rbind(., tall_lpi_plant_codes)

  # exporting to the QC folder
  write.csv(tall_lpi_code_check, file.path(path_qc, "tall_lpi_code_check.csv"), row.names = FALSE)

  select_me <- c("PrimaryKey", "LineKey", "RecKey","TopCanopy", "SoilSurface")
  og_layers <- tblLPIDetail |> dplyr:: select( all_of(select_me), contains("Lower") & !contains("Chk")& !contains("Height")& !contains("Species"))
  og_layers <- gather(og_layers, layer, code, -PrimaryKey, -LineKey, -RecKey)
  og_layers <- og_layers |> dplyr::filter(code != "None", !is.na(code))

  tall_lpi_layer_codes <- tall_lpi |> dplyr::select(PrimaryKey, LineKey, RecKey,layer, code)
  tall_lpi_layer_codes$LineKey <- as.numeric(tall_lpi_layer_codes$LineKey)
  missing_in_tall_lpi <- dplyr::setdiff(og_layers, tall_lpi_layer_codes)
  missing_in_tall_lpi <- as.data.frame(missing_in_tall_lpi)
  if(nrow(missing_in_tall_lpi) > 0){
    missing_in_tall_lpi$Notes <- "The specific hit (layer and code) in tall lpi does not match the original data"
    missing_in_tall_lpi$Action <- "Determine why gather or cleaning is changing the original data"

  }

  missing_in_og <- dplyr::setdiff(tall_lpi_layer_codes, og_layers)
  missing_in_og <- as.data.frame(missing_in_og)
  if(nrow(missing_in_og) > 0){
    missing_in_og$Notes <- "The specific hit (layer and code) in original data does not match or is missing from the tall lpi data"
    missing_in_og$Action <- "Determine why gather or cleaning is changing the tall data"

  }

  if(length(missing_in_og) ==  length(missing_in_tall_lpi)){
    missing_layer_codes <- rbind(missing_in_tall_lpi, missing_in_og)
  }
  if(length(missing_in_og) >  length(missing_in_tall_lpi)){
    missing_layer_codes <- missing_in_og
  }

  if(length(missing_in_og) <  length(missing_in_tall_lpi)){
    missing_layer_codes <- missing_in_tall_lpi
  }

  missing_layer_codes <- as.data.frame(missing_layer_codes)

  if(nrow(missing_layer_codes) > 0){
    missing_layer_codes <- missing_layer_codes |> filter_all(any_vars(duplicated(.)))
  }

  write.csv(missing_layer_codes, file.path(path_qc, "differing_layer_codes_check.csv"), row.names = F)

}
############################################

