

####################################
#' Tall LPI QC
#'
#'after the lpi tall table is prepared for terradactylutils2::geofiles() using terradactylutils2::clean_tall_lpi(), this function produces the tall_lpi file QC checks
#'
#' @param cleaned_tall_lpi as a data.frame, the tall lpi data that has been through terradactylutils2::clean_tall_lpi
#' @param speciescode the column name in the USDA plant list file that contains the four letter codes
#' @param USDA_plants a data.frame of the USDA plants with the 4 letter code, GrowthHabit and Duration
#' @param tblLPIDetail as a data.frame, the tblLPIDetail from the DIMA tables
#' @param path_qc path where the QC data will be saved
#'
#' @return a CSV containing information about the QC of the tall lpi data saved to the designated QC file
#' @export
#'
#' @examples tall_lpi_qc(cleaned_tall_lpi = cleaned_tall_lpi, speciescode = "UpdatedSpeciesCode", tblLPIDetail = tblLPIDetail, USDA_plants = read.csv("D:/modifying_data_prep_script_10032025/2004-2023_ceap_species_list.csv") , path_qc = file.path("D:/modifying_data_prep_script_10032025/NWERN_HAFB_10132025/QC")))
tall_lpi_qc <- function(cleaned_tall_lpi, speciescode, USDA_plants, tblLPIDetail, path_qc){
  # list two letter codes and compare to terradat
tall_lpi <- cleaned_tall_lpi
  #get two letter codes
  two_letter <- tall_lpi[nchar(tall_lpi$code) <= 2, ]

  # only keep the unique codes
  #two_letter <- two_letter[!duplicated(two_letter$code),]

  # this is the list currently used in terradactyl for two letter codes
  terra_two_letter <- c("L","HL", "AM", "DN", "ER", "HT", "NL","AL","DS","D","LC","M","WL", "CY","EL",
                        "W","WA","RF","R","GR","ST","CB","BY","VL","AG","CM","LM","FG","PC",
                        "BR","S")
  # determine whether the tall lpi code is associated with the terradactyl two letter codes, if not provide feedback
  two_letter$tl_error <- ifelse(two_letter$code %in% terra_two_letter, 0, 1)
  two_letter$Notes <- ifelse(two_letter$tl_error == 1,
                             "Two letter codes present that are not associated with terradactyl codes", NA)
  two_letter$Action = ifelse(two_letter$tl_error == 1, "Check with project manager to determine what code represents", NA)
  two_letter <- two_letter |> dplyr::select(PrimaryKey, DBKey, LineKey, RecKey, layer, code, Notes, Action)

  # joining multiple tall lpi tables was machine space expensive - only keeping the plots with feedback for later joining
  two_letter <- two_letter[!is.na(two_letter$Notes),]



  # check same number of unique codes as og data
  # get the unique codes from the original data table
  og_codes <- c(tblLPIDetail$TopCanopy, tblLPIDetail$Lower1, tblLPIDetail$Lower2, tblLPIDetail$Lower3,
                tblLPIDetail$Lower4,tblLPIDetail$Lower5, tblLPIDetail$Lower6, tblLPIDetail$Lower7,
                tblLPIDetail$SoilSurface)
  og_codes <- unique(og_codes)

  #determine whether the tall lpi code is a code from the original data
  tall_lpi_codes <- tall_lpi

  tall_lpi_codes$add_codes <- ifelse(tall_lpi_codes$code %in% og_codes, 0, 1)

  # provide feedback where tall lpi codes are not in the original data
  tall_lpi_codes$Notes <- ifelse(tall_lpi_codes$add_codes == 1,
                                 "Codes present that are not in the original data", NA)

  tall_lpi_codes$Action <- ifelse(tall_lpi_codes$add_codes == 1,
                                  "Determine whether code addition was intentional", NA)
  tall_lpi_codes <- tall_lpi_codes |> dplyr::select(PrimaryKey, DBKey, LineKey, RecKey, layer, code, Notes, Action)

  # joining multiple tall lpi tables was machine space expensive - only keeping the plots with feedback for later joining
  tall_lpi_codes <- tall_lpi_codes[!is.na(tall_lpi_codes$Notes),]




  # looking for soil surface codes that are not terradactyl accepted soil surface codes
  # get the unique two letter soil surface codes from the tall lpi
  ss <- tall_lpi |> filter(layer == "SoilSurface")
  ss <- ss[nchar(ss$code) <= 2, ]
  #ss <- ss[!duplicated(ss$code),]
  # these are the two letter surface codes used in terradactyl
  terra_two_letter_surf <- c("DS","D","LC","M", "CY", "EL",
                             "W","WA","RF","R","GR","ST","CB","BY","VL","AG","CM","LM","FG","PC",
                             "BR","S")

  # determine whether the tall lpi surface code is one of the codes from terradactyl

  ss$add_codes <- ifelse(ss$code %in% terra_two_letter_surf, 0, 1)

  # provide feedback where the tall lpi surface code is not associated with the terradactyl codes
  ss$Notes <- ifelse( ss$add_codes == 1,
                      "Soil surface codes present that are not associated with terradactyl", NA)

  ss$Action <- ifelse(ss$add_codes == 1,
                      "Check with the project manager to determine what the code represents", NA)
  ss <- ss |> dplyr::select(PrimaryKey, DBKey, LineKey, RecKey, layer, code, Notes, Action)

  # joining multiple tall lpi tables was machine space expensive - only keeping the plots with feedback for later joining
  ss <- ss[!is.na(ss$Notes),]



  ## identifying where the tall lpi codes are not a USDA plant code
  #get the accepted USDA plant codes
  USDA_plant_codes <- USDA_plants[,paste0(speciescode)]


  # checking that the tall_lpi codes are in the USDA database
  tall_lpi_plant_codes <- tall_lpi[nchar(tall_lpi$code) > 2, ]


  tall_lpi_plant_codes$usda_code <- ifelse(tall_lpi_plant_codes$code %in% USDA_plant_codes, 0, 1)

  # providing feedback for the tall lpi codes that are not in the USDA plant code list
  tall_lpi_plant_codes$Notes <- ifelse( tall_lpi_plant_codes$usda_code == 1,
                                        "Codes present that are not an accepted USDA plant code", NA)
  tall_lpi_plant_codes$Action <- ifelse(tall_lpi_plant_codes$usda_code ==1,
                                        "If not unknown code, confirm with project manager the correct USDA plant code or species attributes", NA)
  tall_lpi_plant_codes <- tall_lpi_plant_codes |> dplyr::select(PrimaryKey, DBKey, LineKey, RecKey, layer, code, Notes, Action)

  # joining multiple tall lpi tables was machine space expensive - only keeping the plots with feedback for later joining
  tall_lpi_plant_codes <- tall_lpi_plant_codes[!is.na(tall_lpi_plant_codes$Notes),]


  # joining the errors for the tall lpi data

  tall_lpi_code_check <-  rbind(two_letter, tall_lpi_codes) %>%
    rbind(., ss) %>% rbind(., tall_lpi_plant_codes)

  # exporting to the QC folder
  write.csv(tall_lpi_code_check, file.path(path_qc, "tall_lpi_code_check.csv"), row.names = FALSE)

  select_me <- c("PrimaryKey", "LineKey", "RecKey","TopCanopy", "SoilSurface")
  og_layers <- tblLPIDetail |> dplyr:: select( all_of(select_me), contains("Lower") & !contains("Chk")& !contains("Height")& !contains("Species"))
  og_layers <- gather(og_layers, layer, code, -PrimaryKey, -LineKey, -RecKey)
  og_layers <- og_layers |> dplyr::filter(code != "None", !is.na(code))

  tall_lpi_layer_codes <- tall_lpi |> dplyr::select(PrimaryKey, LineKey, RecKey,layer, code)
  tall_lpi_layer_codes$LineKey <- as.numeric(tall_lpi_layer_codes$LineKey)
  missing_in_tall_lpi <- dplyr::setdiff(og_layers, tall_lpi_layer_codes)
  missing_in_tall_lpi <- as.data.frame(missing_in_tall_lpi)
  if(nrow(missing_in_tall_lpi) > 0){
    missing_in_tall_lpi$Notes <- "The specific hit (layer and code) in tall lpi does not match the original data"
    missing_in_tall_lpi$Action <- "Determine why gather or cleaning is changing the original data"

  }

  missing_in_og <- dplyr::setdiff(tall_lpi_layer_codes, og_layers)
  missing_in_og <- as.data.frame(missing_in_og)
  if(nrow(missing_in_og) > 0){
    missing_in_og$Notes <- "The specific hit (layer and code) in original data does not match or is missing from the tall lpi data"
    missing_in_og$Action <- "Determine why gather or cleaning is changing the tall data"

  }

  if(length(missing_in_og) ==  length(missing_in_tall_lpi)){
    missing_layer_codes <- rbind(missing_in_tall_lpi, missing_in_og)
  }
  if(length(missing_in_og) >  length(missing_in_tall_lpi)){
    missing_layer_codes <- missing_in_og
  }

  if(length(missing_in_og) <  length(missing_in_tall_lpi)){
    missing_layer_codes <- missing_in_tall_lpi
  }

  missing_layer_codes <- as.data.frame(missing_layer_codes)

  if(nrow(missing_layer_codes) > 0){
    missing_layer_codes <- missing_layer_codes |> filter_all(any_vars(duplicated(.)))
  }

  write.csv(missing_layer_codes, file.path(path_qc, "differing_layer_codes_check.csv"), row.names = F)

}
############################################






#####################################
#' Tall Gap QC
#'
#' produces QC information using the tall_gap file in the format for running terradactylutils2::geofiles() created using terradactylutils2::clean_tall_gap()
#'
#' @param cleaned_tall_gap the tall_gap file that has been through terradactylutils2::clean_tall_gap()
#' @param tblGapDetail the tblGapDetail file from DIMA tables
#' @param path_qc path where the QC data will be saved
#'
#' @return a CSV with QC information about that tall_gap file saved to the QC folder specified
#' @export
#'
#' @examples gap_qc(cleaned_tall_gap = cleaned_tall_gap, tblGapDetail = tblGapDetail, path_qc = file.path("D:/modifying_data_prep_script_10032025/NWERN_HAFB_10132025/QC"))
tall_gap_qc <- function(cleaned_tall_gap, tblGapDetail, path_qc){
tall_gap <- cleaned_tall_gap
  # function(tblGapDetail, tall_gap)
  ### gap QC
  # checking that the tall and og GapStart data match
  tall_gap_start <- tall_gap |> dplyr::select(PrimaryKey, LineKey, RecKey,GapStart)
  og_gap_start <- tblGapDetail |> dplyr::select(PrimaryKey, LineKey, RecKey,GapStart)

  tall_gap_start_differ <- dplyr::setdiff(og_gap_start, tall_gap_start)
  if(nrow(tall_gap_start_differ) > 0){
    tall_gap_start_differ$Notes <- "There is a GapStart in the tall data that differs from the original data"
    tall_gap_start_differ$Action <- "Determine why gather or clean functions are altering the original GapStart"

  }

  og_gap_start_differ <- dplyr::setdiff(tall_gap_start, og_gap_start)
  if(nrow(og_gap_start_differ) > 0){
    og_gap_start_differ$Notes <- "There is a GapStart in the original data that differs from the tall tables"
    og_gap_start_differ$Action <- "Determine why gather or clean functions are altering the tall GapStart"

  }


  gap_start_errors <- rbind(tall_gap_start_differ, og_gap_start_differ)

  if(nrow(gap_start_errors) > 0){
    gap_start_errors <- gap_start_errors |> filter_all(any_vars(duplicated(.)))
  }


  # checking the GapStart is not NA
  no_start <- tall_gap_start[is.na(tall_gap_start$GapStart),] #
  if(nrow(no_start) > 0){
    no_start$Notes <- "The GapStart for the line is NA"
    no_start$Action <- "Work with project manager to determine whether line needs removed"
  }
  gap_start_errors <- rbind(gap_start_errors, no_start)

  write.csv(gap_start_errors, file.path(path_qc, "GapStart_check.csv"), row.names = F)

  # checking max and min
  tall_gap_gaps <- tall_gap |> dplyr::select(PrimaryKey, LineKey, RecKey,Gap)
  og_gap_gaps <- tblGapDetail |> dplyr::select(PrimaryKey, LineKey, RecKey,Gap)

  max_tall_gap <- slice_max(tall_gap_gaps, Gap, by = c('PrimaryKey', 'LineKey','RecKey'))
  max_og_gap <- slice_max(og_gap_gaps, Gap, by = c('PrimaryKey', 'LineKey','RecKey'))


  max_gap_error_tall <- dplyr::setdiff(max_og_gap, max_tall_gap)
  if(nrow(max_gap_error_tall) > 0){
    max_gap_error_tall$Notes <- "There is a Gap in the tall data that differs from the original data"
    max_gap_error_tall$Action <- "Determine why gather or clean functions are altering the original Gap"

  }

  max_gap_error_og <- dplyr::setdiff(max_tall_gap, max_og_gap)
  if(nrow(max_gap_error_og) > 0){
    max_gap_error_og$Notes <- "There is a Gap in the original data that differs from the tall tables"
    max_gap_error_og$Action <- "Determine why gather or clean functions are altering the tall Gap"

  }


  max_gap_errors <- rbind(max_gap_error_tall, max_gap_error_og)

  if(nrow(max_gap_errors) > 0){
    max_gap_errors <- max_gap_errors |> filter_all(any_vars(duplicated(.)))
  }




  min_tall_gap <- slice_min(tall_gap_gaps, Gap, by = c('PrimaryKey', 'LineKey','RecKey'))
  min_og_gap <- slice_min(og_gap_gaps, Gap, by = c('PrimaryKey', 'LineKey','RecKey'))


  min_gap_error_tall <- dplyr::setdiff(min_og_gap, min_tall_gap)
  if(nrow(min_gap_error_tall) > 0){
    min_gap_error_tall$Notes <- "There is a Gap in the tall data that differs from the original data"
    min_gap_error_tall$Action <- "Determine why gather or clean functions are altering the original Gap"

  }

  min_gap_error_og <- dplyr::setdiff(min_tall_gap, min_og_gap)
  if(nrow(min_gap_error_og) > 0){
    min_gap_error_og$Notes <- "There is a Gap in the original data that differs from the tall tables"
    min_gap_error_og$Action <- "Determine why gather or clean functions are altering the tall Gap"

  }


  min_gap_errors <- rbind(min_gap_error_tall, min_gap_error_og)

  if(nrow(min_gap_errors) > 0){
    min_gap_errors <- min_gap_errors |> filter_all(any_vars(duplicated(.)))
  }


  gap_errors <- rbind(max_gap_errors, min_gap_errors)

  ## checking for negatives or NAs
  neg_gap <- tall_gap_gaps |> filter(Gap < 0)
  if(nrow(neg_gap) > 0){
    neg_gap$Notes <- "There are negative gaps present"
    neg_gap$Action <- "Determine if the gap should be positive or work with project manager to determine whether line needs removed"
  }
  gap_errors <- rbind(gap_errors, neg_gap)

  write.csv(gap_errors, file.path(path_qc, "Gap_check.csv"), row.names = F)

  # GapEnd errors
  tall_gap_end <- tall_gap |> dplyr::select(PrimaryKey, LineKey, RecKey,GapEnd)

  no_end <- tall_gap_end[is.na(tall_gap_end$GapEnd),]

  if(nrow(no_end) > 0){
    no_end$Notes <- "The GapEnd is NA"
    no_end$Action <- "Work with project manager to determine whether line needs removed"
  }

  write.csv(no_end, file.path(path_qc, "GapEnd_check.csv"), row.names = F)

}
#####################################



##################################
#' Tall Soil Stability QC
#'
#'produces QC information using the tall_soil_stability file prepared for terradactylutils2::geofiles() using terradactylutils2::clean_tall_soil_stability()
#'
#' @param tblSoilStabDetail tblSoilStabDetail from the DIMA tables
#' @param cleaned_tall_soil_stability tall_soil_stability created using terradactylutils2::clean_tall_soil_stability()
#' @param path_qc path where the QC data will be saved
#'
#' @return a CSV with information about the tall soil stability QC
#' @export
#'
#' @examples soil_stability_qc(tblSoilStabDetail = tblSoilStabDetail, cleaned_tall_soil_stability = cleaned_tall_soil_stability, path_qc = file.path("D:/modifying_data_prep_script_10032025/NWERN_HAFB_10132025/QC"))
tall_soil_stability_qc <- function(tblSoilStabDetail, cleaned_tall_soil_stability, path_qc){
tall_soil_stability <- cleaned_tall_soil_stability
  # SS rating errors
  ss_og_rating <- tblSoilStabDetail |> dplyr::select(contains("Rating"),  RecKey) |>
    gather("Position", "Rating"  , -RecKey)
  ss_og_rating$Position <- gsub("^.{0,6}", "", ss_og_rating$Position)


  ss_og_rating_2 <- tblSoilStabDetail |> dplyr::select(contains("Pos"), RecKey) |>
    gather("Position", "Pos"  , -RecKey)
  ss_og_rating_2$Position <- gsub("^.{0,3}", "", ss_og_rating_2$Position)

  ss_og_rating <- merge(ss_og_rating, ss_og_rating_2)

  ss_og_rating <- ss_og_rating[!is.na(ss_og_rating$Rating),]
  ss_og_rating <- ss_og_rating[!is.na(ss_og_rating$Pos),]

  ss_tall_rating <- tall_soil_stability |> dplyr::select(RecKey, Pos, Rating, Position)

  # checking max and min



  max_tall_rating <- slice_max(ss_tall_rating, Rating, by = c('Position', 'Pos','RecKey'))
  max_og_rating <- slice_max(ss_og_rating, Rating, by = c('Position', 'Pos','RecKey'))

  max_tall_rating$Position <- as.character(max_tall_rating$Position)
  max_og_rating$Position <- as.character(max_og_rating$Position)
  max_og_rating$Pos <- as.character(max_og_rating$Pos)
  max_tall_rating$Pos <- as.character(max_tall_rating$Pos)

  max_rating_error_tall <- dplyr::setdiff(max_og_rating, max_tall_rating)
  if(nrow(max_rating_error_tall) > 0){
    max_rating_error_tall$Notes <- "There is a rating in the tall data that differs from the original data"
    max_rating_error_tall$Action <- "Determine why gather or clean functions are altering the original rating"

  }

  max_rating_error_og <- dplyr::setdiff(max_tall_rating, max_og_rating)
  if(nrow(max_rating_error_og) > 0){
    max_rating_error_og$Notes <- "There is a rating in the original data that differs from the tall tables"
    max_rating_error_og$Action <- "Determine why gather or clean functions are altering the tall rating"

  }


  max_rating_errors <- rbind(max_rating_error_tall, max_rating_error_og)

  if(nrow(max_rating_errors) > 0){
    max_rating_errors <- max_rating_errors |> filter_all(any_vars(duplicated(.)))
  }




  min_tall_rating <- slice_min(ss_tall_rating, Rating, by = c('Position', 'Pos','RecKey'))
  min_og_rating <- slice_min(ss_og_rating, Rating, by = c('Position', 'Pos','RecKey'))

  min_tall_rating$Position <- as.character(min_tall_rating$Position)
  min_og_rating$Position <- as.character(min_og_rating$Position)
  min_og_rating$Pos <- as.character(min_og_rating$Pos)

  min_tall_rating$Pos <- as.character(min_tall_rating$Pos)

  min_rating_error_tall <- dplyr::setdiff(min_og_rating, min_tall_rating)
  if(nrow(min_rating_error_tall) > 0){
    min_rating_error_tall$Notes <- "There is a rating in the tall data that differs from the original data"
    min_rating_error_tall$Action <- "Determine why gather or clean functions are altering the original rating"

  }

  min_rating_error_og <- dplyr::setdiff(min_tall_rating, min_og_rating)
  if(nrow(min_rating_error_og) > 0){
    min_rating_error_og$Notes <- "There is a rating in the original data that differs from the tall tables"
    min_rating_error_og$Action <- "Determine why gather or clean functions are altering the tall rating"

  }


  min_rating_errors <- rbind(min_rating_error_tall, min_rating_error_og)

  if(nrow(min_rating_errors) > 0){
    min_rating_errors <- min_rating_errors |> filter_all(any_vars(duplicated(.)))
  }


  rating_errors <- rbind(max_rating_errors, min_rating_errors)




  # SS shouldn't be more than 6 in raw and calcd

  ss_raw_six <- ss_og_rating |> filter(Rating >6)
  if(nrow(ss_raw_six) > 0){
    ss_raw_six$Notes <- "There is a rating in the original soil stability data that is greater than 6"
    ss_raw_six$Action <- "Work with the project manager to determine if the rating should be removed"

  }


  ss_calcd_six <- ss_tall_rating |> filter(Rating > 6)
  if(nrow(ss_calcd_six) > 0){
    ss_calcd_six$Notes <- "There is a rating in the tall soil stability data that is greater than 6"
    ss_calcd_six$Action <- "Work with the project manager to determine if the rating should be removed"

  }

  ss_six <- rbind(ss_raw_six, ss_calcd_six)

  if(nrow(ss_six) > 0){
    ss_six <- ss_six |> filter_all(any_vars(duplicated(.)))
  }



  ss_rating_errors <- rbind(rating_errors, ss_six)

  # write CSV
  write.csv(ss_rating_errors,   file.path(path_qc, "soil_stability_rating_check.csv"), row.names = F)


  # veg cover classes
  ss_og_veg <- tblSoilStabDetail |> dplyr::select(contains("Veg"),  RecKey) |>
    gather("Position", "Veg"  , -RecKey)
  ss_og_veg$Position <- gsub("^.{0,3}", "", ss_og_veg$Position)


  ss_og_veg_2 <- tblSoilStabDetail |> dplyr::select(contains("Pos"), RecKey) |>
    gather("Position", "Pos"  , -RecKey)
  ss_og_veg_2$Position <- gsub("^.{0,3}", "", ss_og_veg_2$Position)

  ss_og_veg <- merge(ss_og_veg, ss_og_veg_2)

  ss_og_veg <- ss_og_veg[!is.na(ss_og_veg$Veg),]
  ss_og_veg <- ss_og_veg[!is.na(ss_og_veg$Pos),]

  ss_tall_veg <- tall_soil_stability |> dplyr::select(RecKey, Pos, Veg, Position)


  ss_og_veg$Position <- as.character(ss_og_veg$Position)
  ss_tall_veg$Position <- as.character(ss_tall_veg$Position)
  ss_og_veg$Pos <- as.character(ss_og_veg$Pos)
  ss_tall_veg$Pos <- as.character(ss_tall_veg$Pos)

  veg_error_tall <- dplyr::setdiff(ss_og_veg, ss_tall_veg)
  if(nrow(veg_error_tall) > 0){
    veg_error_tall$Notes <- "There is a Veg record in the tall data that differs from the original data"
    veg_error_tall$Action <- "Determine why gather or clean functions are altering the original Veg"

  }

  veg_error_og <- dplyr::setdiff(ss_tall_veg, ss_og_veg)
  if(nrow(veg_error_og) > 0){
    veg_error_og$Notes <- "There is a Veg record in the original data that differs from the tall tables"
    veg_error_og$Action <- "Determine why gather or clean functions are altering the tall Veg"

  }


  veg_errors <- rbind(veg_error_tall, veg_error_og)

  if(nrow(veg_errors) > 0){
    veg_errors <-veg_errors |> filter_all(any_vars(duplicated(.)))
  }

  write.csv(veg_errors, file.path(path_qc, "soil_stability_Veg_check.csv"), row.names = F)


}
########################################





##################################
#' Tall Height QC
#'
#' produces QC information using the tall_height file produced from terradactylutils2::clean_tall_height()
#'
#' @param tblLPIDetail as a data.frame, tblLPIDetail from the DIMATables
#' @param cleaned_tall_height as a data.frame, the tall_height file produced from terradactylutils2::clean_tall_height()
#' @param path_qc path where the QC data will be saved
#'
#' @return a CSV file with QC information about the height data saved to the specified path_qc
#' @export
#'
#' @examples height_qc(tblLPIDetail = tblLPIDetail, cleaned_tall_height = cleaned_tall_height, path_qc = file.path("D:/modifying_data_prep_script_10032025/NWERN_HAFB_10132025/QC"))
tall_height_qc <- function(tblLPIDetail, cleaned_tall_height, path_qc){
  ### HGT QC
  # checking heights are the same in the original and tall data
tall_height <- cleaned_tall_height
  heights_og <- tblLPIDetail |> dplyr::select(PrimaryKey, LineKey, PointNbr, HeightWoody, HeightHerbaceous)

  heights_og <- gather(heights_og, "type", "Height", -PrimaryKey, -LineKey,-PointNbr)
  heights_og$type <- gsub("^.{0,6}", "", heights_og$type)

  heights_og$type <- tolower(heights_og$type)

  heights_og <- heights_og[!is.na(heights_og$Height),]
  tall_height_max <- tall_height |> dplyr::select(PrimaryKey, LineKey, PointNbr, type, Height)

  max_tall_Height <- slice_max(tall_height_max, Height, by = c('PrimaryKey', 'LineKey','PointNbr'))
  max_og_Height <- slice_max(heights_og, Height, by = c('PrimaryKey', 'LineKey','PointNbr'))


  max_Height_error_tall <- dplyr::setdiff(max_og_Height, max_tall_Height)
  if(nrow(max_Height_error_tall) > 0){
    max_Height_error_tall$Notes <- "There is a max Height in the tall data that differs from the original data"
    max_Height_error_tall$Action <- "Determine why gather or clean functions are altering the original Height"

  }

  max_Height_error_og <- dplyr::setdiff(max_tall_Height, max_og_Height)
  if(nrow(max_Height_error_og) > 0){
    max_Height_error_og$Notes <- "There is a max Height in the original data that differs from the tall tables"
    max_Height_error_og$Action <- "Determine why gather or clean functions are altering the tall Height"

  }


  max_Height_errors <- rbind(max_Height_error_tall, max_Height_error_og)

  if(nrow(max_Height_errors) > 0){
    max_Height_errors <- max_Height_errors |> filter_all(any_vars(duplicated(.)))
  }




  min_tall_Height <- slice_min(tall_height_max, Height, by = c('PrimaryKey', 'LineKey','PointNbr'))
  min_og_Height <- slice_min(heights_og, Height, by = c('PrimaryKey', 'LineKey','PointNbr'))

  min_Height_error_tall <- dplyr::setdiff(min_og_Height, min_tall_Height)
  if(nrow(min_Height_error_tall) > 0){
    min_Height_error_tall$Notes <- "There is a min Height in the tall data that differs from the original data"
    min_Height_error_tall$Action <- "Determine why gather or clean functions are altering the original Height"

  }

  min_Height_error_og <- dplyr::setdiff(min_tall_Height, min_og_Height)
  if(nrow(min_Height_error_og) > 0){
    min_Height_error_og$Notes <- "There is a min Height in the original data that differs from the tall tables"
    min_Height_error_og$Action <- "Determine why gather or clean functions are altering the tall Height"

  }


  min_Height_errors <- rbind(min_Height_error_tall, min_Height_error_og)

  if(nrow(min_Height_errors) > 0){
    min_Height_errors <- min_Height_errors |> filter_all(any_vars(duplicated(.)))
  }


  Height_errors <- rbind(max_Height_errors, min_Height_errors)

  write.csv(Height_errors, file.path(path_qc, "Height_check.csv"), row.names = F)

}
#########################################
